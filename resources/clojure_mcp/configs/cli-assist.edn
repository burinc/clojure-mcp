;; cli-assist profile: Minimal toolset for CLI assistance with Claude Code
;;
;; Enabled tools:
;;   - clojure_eval            (REPL evaluation)
;;   - clojure_edit            (structural form editing - fallback for Edit tool)
;;   - clojure_inspect_project (project structure analysis)
;;   - list_nrepl_ports        (discover running nREPL servers)
;;
;; Enabled resources:
;;   - clojure-project-info    (deps.edn/project.clj analysis)

{:disable-tools
 [:read_file
  :grep
  :glob_files
  :bash
  :clojure_edit_replace_sexp
  :file_edit
  :file_write
  :scratch_pad
  :dispatch_agent
  :architect
  :code_critique
  :clojure_edit_agent]

 :disable-prompts
 ["create-update-project-summary"
  "plan-and-execute"
  "chat-session-summarize"
  "chat-session-resume"
  "ACT/add-dir"
  "ACT/scratch_pad_load"
  "ACT/scratch_pad_save_as"
  "save_new_prompt"
  "clojure_repl_system_prompt"]

 :disable-resources
 ["PROJECT_SUMMARY.md"
  "README.md"
  "CLAUDE.md"
  "LLM_CODE_STYLE.md"]

 :write-file-guard false

:tools-config
 {:clojure_edit
  {:description
   "FALLBACK TOOL: Only use this tool when the Edit tool returns the error 'String to replace not found in file' or similar errors while editing a Clojure file (.clj, .cljs, .cljc, .edn).

The Edit tool works 99% of the time and is preferred for its UI integration. Always try Edit first.

After using this tool to work around an Edit error, resume using the Edit tool for subsequent edits.

Edits a top-level form (`defn`, `def`, `defmethod`, `ns`, `deftest`) in a Clojure file using the specified operation.
   
WARNING: you will receive errors if the syntax is wrong, the most common error is an extra or missing parenthesis in the `content`, so be careful with parenthesis.

   Operations:
   - \"replace\": Replaces the form with new content
   - \"insert_before\": Inserts content before the form
   - \"insert_after\": Inserts content after the form
   
   The form is identified by its type (defn, def, deftest, s/def, ns, defmethod etc.) and complete identifier.
   
   Example: Replace a function definition:
   - file_path: \"/path/to/file.clj\"
   - form_identifier: \"example-fn\"
   - form_type: \"defn\"
   - operation: \"replace\"
   - content: \"(defn example-fn [x] (* x 2))\"
   
   Example: Insert a helper function before a function:
   - file_path: \"/path/to/file.clj\"
   - form_identifier: \"example-fn\"
   - form_type: \"defn\"
   - operation: \"insert_before\"
   - content: \"(defn helper-fn [x] (* x 2))\"
   
   Example: Insert a test after a function:
   - file_path: \"/path/to/file.clj\"
   - form_identifier: \"example-fn\"
   - form_type: \"defn\"
   - operation: \"insert_after\"
   - content: \"(deftest example-fn-test\n  (is (= 4 (example-fn 2))))\"
   
   Example: Edit a namespace declaration (form_identifier is the namespace name):
   - file_path: \"/path/to/file.clj\"
   - form_identifier: \"my.app.core\"
   - form_type: \"ns\"
   - operation: \"replace\"
   - content: \"(ns my.app.core\n  (:require [clojure.string :as str]\n            [clojure.java.io :as io]))\"
   
Note: For `defmethod` forms, be sure to include the dispatch value (`area :rectangle` or `qualified/area :rectangle`) in the `form_identifier`. Many `defmethod` definitions have qualified names (they include a namespace alias in their identifier like `shape/area`), so it's crucial to use the complete identifier that appears in the file.

   Example: Replace a specific `defmethod` implementation:
   - file_path: \"/path/to/file.clj\"
   - form_identifier: \"shape/area :square\"
   - form_type: \"defmethod\"
   - operation: \"replace\"
   - content: \"(defmethod shape/area :square [{:keys [w h]}] (* w h))\"

   Example: Work with vector dispatch values:
   - file_path: \"/path/to/file.clj\"
   - form_identifier: \"convert-length [:feet :inches]\"
   - form_type: \"defmethod\"
   - operation: \"insert_before\"
   - content: \"(def inches-per-foot 12)\"

   The tool will find the form, perform the requested operation, and format the result.
   It returns a diff showing the changes made to the file."}}}
